               Работа с XMS-памятью в реальном режиме

                                        Красиков Игорь Владимирович.


       Подгружаемый драйвер  XMS  extended-памяти  позволяет  Вам
 достаточно просто и удобно оперировать с extended-памятью. В от-
 личие от EMS XMS не имеет страничной адресации,  а располагается
 непрерывным блоком,  для доступа к  которому  Вам  следует  лишь
 знать необходимое Вам смещение в этом блоке.  Драйвер предостав-
 ляет существенно большие возможности, чем 87h функция прерывания
 15h.
       Рассмотрим работу с extended-памятью при помощи  XMS-драй-
 вера более детально.
       Определение, загружен ли XMS-драйвер, произволится при по-
 мощи прерывания 2Fh,  функции 4300h:  если при вызове прерывания
 2Fh при AX=4300h мы получаем AL=80h, драйвер установлен и следу-
 ющим шагом  мы  определяем  адрес,  по которому следует вызывать
 программу драйвера (в отличие от EMS драйвера,  где все  функции
 работы с EMS памятью оформлены в виде функций прерывания 67h,  к
 XMS драйверу следует обращаться через вызов CALL FAR по адресу):
 для этого  вызывается прерывание 2Fh с AX=4301h и регистры ES:BX
 содержат адрес программы драйвера.
       Передача параметров  драйверу производится через регистры,
 при этом в регистр AH помещается номер вызываемой подфункции,  и
 после возврата  из  функции AX содержит 1 в случае успешного вы-
 полнения и 0 в случае неуспешного (что очень приятно при исполь-
 зовании Turbo Pascal - в нем в assembler - функции возврат буле-
 вого значения как раз передается через  регистр  AX  и  1  соот-
 ветствует значению TRUE,  а 0 - FALSE) - за исключением лишь вы-
 зова подфункции 08h, а в регистре BL - код произошедшей ошибки.
       Список основных подфункций:
   00   Получение версии XMS
        Вход - нет, выход AX - версия в BCD-формате,
                          BX - номер разработки
   01   Получение доступа к HMA (High Memory Area)
        Вход  DX - требуемая память в байтах
        Выход - нет (здесь и далее отсутствие выходных данных
                     означает, как уже говорилось, возвращение
                     кода ошибки в BL и флага выполнения в AX)
   02   Освобождение HMA
        Вход - нет, выход - нет.
   08   Информация о доступной extended памяти
        Вход - нет, выход -
                    AX=размер наибольшего доступного блока в K
                    DX=общему количеству extended-памяти в K
                    BL - код ошибки
   09   Зарезервировать блок памяти
        Вход  DX = требуемая память в K
        Выход DX = handle зарезервированного блока
   0A   Освободить блок
        Вход - DX = handle этого блока
        Выход - нет
   0B   Перемещение блока памяти
        Вход DS:SI указывает на EMM-структуру,  в которой содер-
                    жится информация о требуемом перемещении
        Выход - нет
   0С   Закрытие блока extended-памяти
        Вход - DX = handle блока
        Выход - DX:BX - 32-битовый линейный адрес блока
   0D   Открыть блок
        Вход - DX = handle блока
        Выходва - нет
   0E   Получение информации о handl'е
        Вход - DX = интересующий handle
        Выход - BH - количество закрытых блоков
                BL - количество свободных handle'ов
                DX - размер блока в K
   0F   Изменение размера блока
        Вход - DX - handle блока
               BX - новый размер блока в K
        Выход - нет

       Ниже приведен исходный текст модуля XMS.TPU,  реализующего
 все перечисленные функции.  В переменной  XMSerror  возвращается
 значение ошибки после последней операции. Для расшифровки ошибки
 Вы можете  вызвать  функцию  XMSerrorMSG,  возвращающую  строку,
 описывающую ошибку.
       Обратите внимание на то,  как  организован  вызов  функций
 драйвера -  в процедуре CallXMS имеется строка из пяти кодов 90h
 - нет операции - которые при инициализации модуля, если установ-
 лен XMS драйвер, заменяются на код дальнего вызова драйвера.

       Вернемся к вопросу о перемещении extended-памяти. В модуле
 описан тип EMMstruct,  представляющий собой  запись,  в  которой
 size- размер памяти, которую надо переместить, в байтах. Сущест-
 венное ограничение - size должен быть четным числом !
       soh и  soo  - handle и смещение в блоке,  соответствующего
 этому handle'у - для исходного блока,  а dsh и dso - то  же  для
 блока, куда должно быть перенесено содержимое памяти.
       Если какой-либо handle равен нулю, это означает, что пере-
 мещение идет  из/в RAM и смещение - это указатель на место в па-
 мяти (например, так - dso:=LongInt(@Buf)).
       Функция MoveXMS  представляет собой низкоуровневое переме-
 щение блоков памяти, для которого требуется самому заполнить по-
 ля EMM-структуры.  Функции  же Mem2Xms и Xms2Mem позволяют пере-
 носить любое (не обязательно четное!) число  байт  из  памяти  в
 extended-память и обратно (постарайтесь разобраться,  как именно
 преодолено ограничение на четность).

       Существенным дополнением к Turbo Vision является описанный
 в модуле XSTREAM.TPU тип TXmsStream - объект от TStream,  позво-
 ляющий, аналогично стандартному объекту TEmsStream, использующе-
 му EMS   память,   использовать   XMS  память.  Важным  отличием
 TXmsStream является наличие  конструктора  InitH  и  деструктора
 NDDone. Смысл состоит в том, что деструктор NDDone не освобожда-
 ет XMS память, а потому, передав handle в другую программу, Вы в
 состоянии инициализировать   объект   TXmsStream   по   значению
 handle'а - только Вы должны передать и его размер (текущий  раз-
 мер, а не максимальное значение!).
       Последней приведена программа, показывающая применение XMS
 памяти - сохраняя в ней картинку с экрана.

                                        Красиков Игорь Владимирович.

         К.т.н., н.с. отдела 44 (математическое моделирование и вычис-
    лительный эксперимент  в материаловедении) Института проблем мате-
    риаловедения АН Украины.

         Т.р. (044) 444-13-19

         Рабочий адрес: 252142, ГСП, Киев-680,
         ул. Кржижановского, 3. ИПМ АН Украины, отд.44.

         Адрес для контактов -
         252062, Киев-62,
         ул. Чистяковская, 12, кв.28. -
         для Красикова И.В.


